### 用子类替换类型码
#### 问题
你有一个编码类型，它直接影响程序行为（该字段的值触发条件语句中的各种代码）。

#### 解决方案
为编码类型的每个值创建子类。然后将原始类中的相关行为提取到这些子类中。用多态替换控制流代码。

#### 用子类替换类型码 - 之前
#### 用子类替换类型码 - 之后

#### 为何重构
这种重构技术是“用类替换类型码”更复杂的变体。

与第一种重构方法一样，你有一组简单的值，它们构成字段的所有允许值。尽管这些值通常被指定为常量并具有可理解的名称，但它们的使用使你的代码非常容易出错，因为它们实际上仍然是原始类型。例如，你有一个接受这些值之一作为参数的方法。在某个时刻，该方法接收到常量`USER_TYPE_ADMIN`，其值为"ADMIN"，而作者（你）未打算接收到相同的小写字符串("admin")，这将导致执行不同于预期的操作。

这里涉及控制流代码，如条件语句（if、switch和?:）。换句话说，带有编码值的字段（例如`$user->type === self::USER_TYPE_ADMIN`）在这些运算符的条件中使用。如果我们在这里使用“用类替换类型码”，所有这些控制流构造都最好移到负责数据类型的类中。最终，这当然会创建一个与原始类非常相似的类型类，具有相同的问题。

#### 好处
删除控制流代码。将原始类中庞大的switch代码移到相应的子类中。这提高了遵循单一职责原则的程度，并使程序总体更可读。

如果需要为编码类型添加新值，只需添加一个新的子类而无需触及现有代码（参考开闭原则）。

通过用类替换类型码，我们为在编程语言级别的方法和字段提供类型提示铺平了道路。使用编码类型中包含的简单数值或字符串时，这是不可能的。

#### 不适用情况
如果已经有一个类层次结构，这种技术就不适用。在面向对象编程中，无法通过继承创建双重层次结构。但是，你可以使用组合而不是继承来替换类型码。为此，请使用“用状态/策略替换类型码”。

如果类型码的值在对象创建后可能发生变化，请避免使用此技术。我们将不得不以某种方式动态替换对象本身的类，这是不可能的。但是，在这种情况下，替代方法仍然可能是“用状态/策略替换类型码”。

#### 如何重构
1. 使用“自封装字段”创建包含类型码的字段的getter。
2. 将超类构造函数设为私有。创建一个与超类构造函数相同的静态工厂方法。它必须包含将编码类型的起始值传递给它的参数。根据此参数，工厂方法将创建各种子类的对象。为此，在其代码中必须创建一个大的条件语句，但至少当真正需要时，它将是唯一的条件语句；否则，子类和多态性将会起作用。
3. 为编码类型的每个值创建唯一的子类。在子类中，重新定义编码类型的getter，使其返回编码类型的相应值。
4. 从超类中移动字段和方法到相应的子类中（借助“字段下移”和“方法下移”）。
5. 当移动了所有可能的内容后，使用“用多态替换条件语句”来彻底摆脱使用类型码的条件。